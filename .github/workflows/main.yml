name: DevSecOps CI Pipeline ðŸš€

on:
  push:
    branches: [ main ]
    # paths-ignore:
    #   - 'k8s/**' # This line is commented out, meaning changes in k8s/ will trigger the workflow

env:
  AWS_REGION: us-east-1
  ECR_REPOSITORY: my-vite-app
  EKS_CLUSTER_NAME: vite-app-cluster-v2

jobs:
  security-scans:
    name: Security Scanning
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up tfsec config
        run: |
          mkdir -p .tfsec
          echo "---" > .tfsec/config.yml
          echo "exclude:" >> .tfsec/config.yml
          echo "  - aws-eks-no-public-cluster-access" >> .tfsec/config.yml
          echo "  - aws-eks-no-public-cluster-access-to-cidr" >> .tfsec/config.yml
          echo "  - aws-ec2-no-public-egress-sgr" >> .tfsec/config.yml
      - name: Scan Terraform code with tfsec
        run: |
          TFSEC_VERSION=v1.28.14
          wget https://github.com/aquasecurity/tfsec/releases/download/${TFSEC_VERSION}/tfsec-linux-amd64 -O tfsec
          chmod +x tfsec
          sudo mv tfsec /usr/local/bin/tfsec
          tfsec --soft-fail ./infra
      - name: Build Docker image
        run: docker build -t temp-image-for-scan .
      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@0.20.0
        with:
          image-ref: 'temp-image-for-scan'
          format: 'table'
          severity: 'HIGH,CRITICAL'

  build-and-push:
    name: Build & Push to ECR
    runs-on: ubuntu-latest
    needs: security-scans
    permissions:
      contents: read
    outputs:
      image_tag: ${{ steps.build-image.outputs.image-tag }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Configure AWS Credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
      - name: Build, tag, and push image to Amazon ECR
        id: build-image
        env:
          ECR_REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          IMAGE_TAG: ${{ github.sha }}
        run: |
          docker build -t $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG .
          docker push $ECR_REGISTRY/$ECR_REPOSITORY:$IMAGE_TAG
          echo "image-tag=$IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "The image tag being set is: $IMAGE_TAG"

  update-manifest:
    name: Update K8s Manifest & Seal Secrets
    runs-on: ubuntu-latest
    needs: build-and-push
    permissions:
      contents: write # Needed to commit changes back to the repo
      id-token: write # Needed for OIDC authentication with AWS (for kubectl) - good practice
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Print received image tag
        run: |
          echo "Received image tag from previous job: ${{ needs.build-and-push.outputs.image_tag }}"

      # --- Start Sealed Secrets Integration ---
      - name: Configure AWS Credentials for Kubectl
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
          # Uncomment and configure if you use OIDC for your GitHub Actions runner to assume an IAM role
          # role-to-assume: arn:aws:iam::${{ secrets.AWS_ACCOUNT_ID }}:role/github-actions-eks-role
          # role-session-name: github-actions-session

      - name: Install kubectl
        uses: azure/setup-kubectl@v3

      - name: Update Kubeconfig
        run: |
          aws eks update-kubeconfig --region ${{ env.AWS_REGION }} --name ${{ env.EKS_CLUSTER_NAME }}

      - name: Install kubeseal
        run: |
          KUBESEAL_VERSION="0.30.0" # Updated to the latest version
          # Download the tar.gz archive
          curl -OL "https://github.com/bitnami-labs/sealed-secrets/releases/download/v${KUBESEAL_VERSION}/kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz"
          # Extract the kubeseal binary
          tar -xvzf kubeseal-${KUBESEAL_VERSION}-linux-amd64.tar.gz kubeseal
          # Move and set permissions for the binary
          sudo install -m 755 kubeseal /usr/local/bin/kubeseal
          kubeseal --version

      - name: Create and Seal Kubernetes Secret
        env:
          # This secret must be created in your GitHub repository secrets!
          API_KEY: ${{ secrets.VITE_APP_API_KEY_VALUE }}
          SECRET_NAME: vite-app-api-secret # Name of the Kubernetes Secret
          NAMESPACE: default # Namespace where the secret will be deployed
        run: |
          # Create a temporary unsealed secret YAML
          cat <<EOF > /tmp/unsealed-secret.yaml
          apiVersion: v1
          kind: Secret
          metadata:
            name: ${SECRET_NAME}
            namespace: ${NAMESPACE}
          type: Opaque
          data:
            API_KEY: $(echo -n "$API_KEY" | base64) # Base64 encode the secret value
          EOF

          # --- Port-forward sealed-secrets-controller ---
          echo "Attempting to port-forward sealed-secrets controller..."
          kubectl port-forward service/sealed-secrets -n kube-system 8080:8080 > /tmp/port-forward.log 2>&1 &
          PORT_FORWARD_PID=$! # Capture the PID of the background process

          # Wait for the port-forward to establish
          echo "Waiting for port-forward to become active..."
          timeout=60 # seconds
          start_time=$(date +%s)
          while ! nc -z localhost 8080 && [ $(($(date +%s) - start_time)) -lt $timeout ]; do
            sleep 5
            echo "Still waiting for port-forward..."
          done

          if ! nc -z localhost 8080; then
            echo "ERROR: Port-forward failed to establish within $timeout seconds."
            cat /tmp/port-forward.log # Output the port-forward logs for debugging
            kill $PORT_FORWARD_PID || true # Attempt to kill if it's still running
            exit 1
          fi
          echo "Port-forward established. Proceeding with sealing."
          # -----------------------------------------------------------

          # --- NEW: Write kubeseal command to a script and execute it for robustness ---
          # The SEAL_SCRIPT_EOF marker must be unindented to the very first column.
          cat << 'SEAL_SCRIPT_EOF' > /tmp/seal_secret.sh
#!/bin/bash
# Execute kubeseal with explicit arguments
# Capture stderr and stdout for debugging
kubeseal --format yaml \
         --controller-url http://localhost:8080 \
         --name "${SECRET_NAME}" \
         --namespace "${NAMESPACE}" \
         < /tmp/unsealed-secret.yaml \
         > k8s/vite-app-sealed-secret.yaml 2> /tmp/kubeseal_error.log

# Check exit code and print logs if failed
if [ $? -ne 0 ]; then
  echo "ERROR: kubeseal command failed!"
  echo "kubeseal stderr/stdout:"
  cat /tmp/kubeseal_error.log
  exit 1
fi
SEAL_SCRIPT_EOF # <--- THIS LINE IS NOW AT COLUMN 1 (NO INDENTATION).

          chmod +x /tmp/seal_secret.sh
          /tmp/seal_secret.sh # Execute the script
          # -----------------------------------------------------------------------------

          echo "Sealed secret generated at k8s/vite-app-sealed-secret.yaml"

          # Clean up the port-forward process
          kill $PORT_FORWARD_PID || true
      # --- End Sealed Secrets Integration ---

      - name: Update deployment with new image tag
        run: |
          # Ensure you have AWS_ACCOUNT_ID as a GitHub Secret for this line
          sed -i "s|image: .*/${{ env.ECR_REPOSITORY }}:.*|image: ${{ secrets.AWS_ACCOUNT_ID }}.dkr.ecr.${{ env.AWS_REGION }}.amazonaws.com/${{ env.ECR_REPOSITORY }}:${{ needs.build-and-push.outputs.image_tag }}|" k8s/deployment.yaml

      - name: Commit and push changes
        run: |
          git config --global user.name 'github-actions[bot]'
          git config --global user.email 'github-actions[bot]@users.noreply.github.com'
          git add k8s/deployment.yaml k8s/vite-app-sealed-secret.yaml # Add the new sealed secret file
          git commit -m "Updated image tag to ${{ needs.build-and-push.outputs.image_tag }} and sealed secrets" || echo "No changes to commit"
          git push